
/* MACHINE GENERATED By Halide. */

#include <assert.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

void halide_unused(bool e){};

/*@
pure int max(int x, int y) = x > y ? x : y;

pure int min(int x, int y) = x > y ? y : x;

pure float max(float x, float y) = x > y ? x : y;

pure float min(float x, float y) = x > y ? y : x;

pure int abs(int x) = x >= 0 ? x : -x;

pure float abs(float x) = x >= 0 ? x : -x;

// Euclidean division is defined internally in VerCors
pure int euclidean_div(int x, int y);
pure int euclidean_mod(int x, int y);
pure int hdiv(int x, int y) = y == 0 ? 0 : euclidean_div(x, y);
pure int hmod(int x, int y) = y == 0 ? 0 : euclidean_mod(x, y);
@*/

/*@
  requires y != 0;
  ensures \result == euclidean_div(x, y);
@*/
/*inline*/ int /*@ pure @*/ div_eucl(int x, int y)
{
    int q = x/y;
    int r = x%y;
    return r < 0 ? q + (y > 0 ? -1 : 1) : q;
}

/*@
  requires y != 0;
  ensures \result == euclidean_mod(x, y);
@*/
/*inline*/ int /*@ pure @*/ mod_eucl(int x, int y)
{
    int r = x%y;
    return (x >= 0 || r == 0) ? r : r + abs(y);
}

static inline float /*@ pure @*/ fast_inverse_f32(float x) {return 1.0f/x;};
//@ given double eps;
static inline float /*@ pure @*/ sqrt_f32(double x) {return (float)sqrt((double)x)/*@given {eps=eps}@*/;}
static inline float /*@ pure @*/ pow_f32(float x, float y){ return (float) pow((double) x, (double) y);}
static inline float /*@ pure @*/ floor_f32(float x){ return (float) floor((double) x); }
static inline float /*@ pure @*/ ceil_f32(float x){ return (float) ceil((double) x); }
static inline float /*@ pure @*/ round_f32(float x){ return (float) round((double) x); }

//@ given double eps;
static inline double /*@ pure @*/ sqrt_f64(double x) {return sqrt(x)/*@given {eps=eps}@*/;}
static inline double /*@ pure @*/ pow_f64(double x, double y) {return pow(x, y);}
static inline double /*@ pure @*/ floor_f64(double x) {return floor(x);}
static inline double /*@ pure @*/ ceil_f64(double x) {return ceil(x);}
static inline double /*@ pure @*/ round_f64(double x){ return round(x); }



struct halide_dimension_t {
    int32_t min, extent, stride;
};

struct halide_buffer_uint16_t {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    uint16_t *host;
};

/*@ 
 requires buf != NULL ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ uint16_t *_halide_buffer_get_host_uint16_t(struct halide_buffer_uint16_t *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_min_uint16_t(struct halide_buffer_uint16_t *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_max_uint16_t(struct halide_buffer_uint16_t *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_extent_uint16_t(struct halide_buffer_uint16_t *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_stride_uint16_t(struct halide_buffer_uint16_t *buf, int d) {
    return buf->dim[d].stride;
}
struct halide_buffer_float {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    float *host;
};

/*@ 
 requires buf != NULL ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ float *_halide_buffer_get_host_float(struct halide_buffer_float *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_min_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_max_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_extent_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_stride_float(struct halide_buffer_float *buf, int d) {
    return buf->dim[d].stride;
}
struct halide_buffer_uint8_t {

    /** The dimensionality of the buffer. */
    int32_t dimensions;

    /** The shape of the buffer. Halide does not own this array - you
     * must manage the memory for it yourself. */
    struct halide_dimension_t *dim;

    /** A pointer to the start of the data in main memory. In terms of
     * the Halide coordinate system, this is the address of the min
     * coordinates (defined below). */

    uint8_t *host;
};

/*@ 
 requires buf != NULL ** Perm(buf, 1\2);
 requires Perm(buf->host, 1\2);
 @*/
/*@ pure @*/ uint8_t *_halide_buffer_get_host_uint8_t(struct halide_buffer_uint8_t *buf) {
    return buf->host;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_min_uint8_t(struct halide_buffer_uint8_t *buf, int d) {
    return buf->dim[d].min;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].min, 1\2) ** Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_max_uint8_t(struct halide_buffer_uint8_t *buf, int d) {
    return buf->dim[d].min + buf->dim[d].extent - 1;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].extent, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_extent_uint8_t(struct halide_buffer_uint8_t *buf, int d) {
    return buf->dim[d].extent;
}

/*@ 
    requires buf != NULL ** Perm(buf, 1\2);
    requires Perm(buf->dim, 1\2) ** buf->dim != NULL;
    requires 0 <= d && d < \pointer_length(buf->dim);
    requires Perm(&buf->dim[d], 1\2);
    requires Perm(buf->dim[d].stride, 1\2);
@*/
/*@ pure @*/ int _halide_buffer_get_stride_uint8_t(struct halide_buffer_uint8_t *buf, int d) {
    return buf->dim[d].stride;
}
// //@ pure int pure_input(int x);
// //@ pure float pure_matrix_3200(int x);
// //@ pure float pure_matrix_7000(int x);
// //@ pure int pure_processed(int x);



#ifdef __cplusplus
extern "C" {
#endif

/*@
 context _input_buffer != NULL ** Perm(_input_buffer, 1\2);
 context Perm(_input_buffer->dim, 1\2) ** _input_buffer->dim != NULL;
 context \pointer_length(_input_buffer->dim) == 2;
 context Perm(_input_buffer->host, 1\2) ** _input_buffer->host != NULL;
 context Perm(&_input_buffer->dim[0], 1\2);
 context Perm(_input_buffer->dim[0].min, 1\2) ** Perm(_input_buffer->dim[0].stride, 1\2) ** Perm(_input_buffer->dim[0].extent, 1\2);
 context Perm(&_input_buffer->dim[1], 1\2);
 context Perm(_input_buffer->dim[1].min, 1\2) ** Perm(_input_buffer->dim[1].stride, 1\2) ** Perm(_input_buffer->dim[1].extent, 1\2);
 context \pointer_length(_input_buffer->host) == 1 + abs(_input_buffer->dim[0].stride) * (_input_buffer->dim[0].extent - 1) + abs(_input_buffer->dim[1].stride) * (_input_buffer->dim[1].extent - 1);
 context _matrix_3200_buffer != NULL ** Perm(_matrix_3200_buffer, 1\2);
 context Perm(_matrix_3200_buffer->dim, 1\2) ** _matrix_3200_buffer->dim != NULL;
 context \pointer_length(_matrix_3200_buffer->dim) == 2;
 context Perm(_matrix_3200_buffer->host, 1\2) ** _matrix_3200_buffer->host != NULL;
 context Perm(&_matrix_3200_buffer->dim[0], 1\2);
 context Perm(_matrix_3200_buffer->dim[0].min, 1\2) ** Perm(_matrix_3200_buffer->dim[0].stride, 1\2) ** Perm(_matrix_3200_buffer->dim[0].extent, 1\2);
 context Perm(&_matrix_3200_buffer->dim[1], 1\2);
 context Perm(_matrix_3200_buffer->dim[1].min, 1\2) ** Perm(_matrix_3200_buffer->dim[1].stride, 1\2) ** Perm(_matrix_3200_buffer->dim[1].extent, 1\2);
 context \pointer_length(_matrix_3200_buffer->host) == 1 + abs(_matrix_3200_buffer->dim[0].stride) * (_matrix_3200_buffer->dim[0].extent - 1) + abs(_matrix_3200_buffer->dim[1].stride) * (_matrix_3200_buffer->dim[1].extent - 1);
 context _matrix_7000_buffer != NULL ** Perm(_matrix_7000_buffer, 1\2);
 context Perm(_matrix_7000_buffer->dim, 1\2) ** _matrix_7000_buffer->dim != NULL;
 context \pointer_length(_matrix_7000_buffer->dim) == 2;
 context Perm(_matrix_7000_buffer->host, 1\2) ** _matrix_7000_buffer->host != NULL;
 context Perm(&_matrix_7000_buffer->dim[0], 1\2);
 context Perm(_matrix_7000_buffer->dim[0].min, 1\2) ** Perm(_matrix_7000_buffer->dim[0].stride, 1\2) ** Perm(_matrix_7000_buffer->dim[0].extent, 1\2);
 context Perm(&_matrix_7000_buffer->dim[1], 1\2);
 context Perm(_matrix_7000_buffer->dim[1].min, 1\2) ** Perm(_matrix_7000_buffer->dim[1].stride, 1\2) ** Perm(_matrix_7000_buffer->dim[1].extent, 1\2);
 context \pointer_length(_matrix_7000_buffer->host) == 1 + abs(_matrix_7000_buffer->dim[0].stride) * (_matrix_7000_buffer->dim[0].extent - 1) + abs(_matrix_7000_buffer->dim[1].stride) * (_matrix_7000_buffer->dim[1].extent - 1);
 context _processed_buffer != NULL ** Perm(_processed_buffer, 1\2);
 context Perm(_processed_buffer->dim, 1\2) ** _processed_buffer->dim != NULL;
 context \pointer_length(_processed_buffer->dim) == 3;
 context Perm(_processed_buffer->host, 1\2) ** _processed_buffer->host != NULL;
 context Perm(&_processed_buffer->dim[0], 1\2);
 context Perm(_processed_buffer->dim[0].min, 1\2) ** Perm(_processed_buffer->dim[0].stride, 1\2) ** Perm(_processed_buffer->dim[0].extent, 1\2);
 context Perm(&_processed_buffer->dim[1], 1\2);
 context Perm(_processed_buffer->dim[1].min, 1\2) ** Perm(_processed_buffer->dim[1].stride, 1\2) ** Perm(_processed_buffer->dim[1].extent, 1\2);
 context Perm(&_processed_buffer->dim[2], 1\2);
 context Perm(_processed_buffer->dim[2].min, 1\2) ** Perm(_processed_buffer->dim[2].stride, 1\2) ** Perm(_processed_buffer->dim[2].extent, 1\2);
 context \pointer_length(_processed_buffer->host) == 1 + abs(_processed_buffer->dim[0].stride) * (_processed_buffer->dim[0].extent - 1) + abs(_processed_buffer->dim[1].stride) * (_processed_buffer->dim[1].extent - 1) + abs(_processed_buffer->dim[2].stride) * (_processed_buffer->dim[2].extent - 1);
 context _matrix_7000_buffer->host != _matrix_3200_buffer->host;
 context _processed_buffer->host != _input_buffer->host;
 context ((_halide_buffer_get_min_uint16_t(_input_buffer, 0) == 0) && (_halide_buffer_get_extent_uint16_t(_input_buffer, 0) == 2592)) && (_halide_buffer_get_stride_uint16_t(_input_buffer, 0) == 1);
 context ((_halide_buffer_get_min_uint16_t(_input_buffer, 1) == 0) && (_halide_buffer_get_extent_uint16_t(_input_buffer, 1) == 1968)) && (_halide_buffer_get_stride_uint16_t(_input_buffer, 1) == 2592);
 context (\forall* int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); Perm(&_input_buffer->host[(_1*2592) + _0], 1\2));
 //context (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input_buffer->host[(_1*2592) + _0] == pure_input((_1*2592) + _0));
 context ((_halide_buffer_get_min_float(_matrix_3200_buffer, 0) == 0) && (_halide_buffer_get_extent_float(_matrix_3200_buffer, 0) == 4)) && (_halide_buffer_get_stride_float(_matrix_3200_buffer, 0) == 1);
 context ((_halide_buffer_get_min_float(_matrix_3200_buffer, 1) == 0) && (_halide_buffer_get_extent_float(_matrix_3200_buffer, 1) == 3)) && (_halide_buffer_get_stride_float(_matrix_3200_buffer, 1) == 4);
 context (\forall* int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); Perm(&_matrix_3200_buffer->host[(_1*4) + _0], 1\2));
 //context (\forall int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); _matrix_3200_buffer->host[(_1*4) + _0] == pure_matrix_3200((_1*4) + _0));
 context ((_halide_buffer_get_min_float(_matrix_7000_buffer, 0) == 0) && (_halide_buffer_get_extent_float(_matrix_7000_buffer, 0) == 4)) && (_halide_buffer_get_stride_float(_matrix_7000_buffer, 0) == 1);
 context ((_halide_buffer_get_min_float(_matrix_7000_buffer, 1) == 0) && (_halide_buffer_get_extent_float(_matrix_7000_buffer, 1) == 3)) && (_halide_buffer_get_stride_float(_matrix_7000_buffer, 1) == 4);
 context (\forall* int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); Perm(&_matrix_7000_buffer->host[(_1*4) + _0], 1\2));
 //context (\forall int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); _matrix_7000_buffer->host[(_1*4) + _0] == pure_matrix_7000((_1*4) + _0));
 context ((_halide_buffer_get_min_uint8_t(_processed_buffer, 0) == 0) && (_halide_buffer_get_extent_uint8_t(_processed_buffer, 0) == 2560)) && (_halide_buffer_get_stride_uint8_t(_processed_buffer, 0) == 1);
 context ((_halide_buffer_get_min_uint8_t(_processed_buffer, 1) == 0) && (_halide_buffer_get_extent_uint8_t(_processed_buffer, 1) == 1920)) && (_halide_buffer_get_stride_uint8_t(_processed_buffer, 1) == 2560);
 context ((_halide_buffer_get_min_uint8_t(_processed_buffer, 2) == 0) && (_halide_buffer_get_extent_uint8_t(_processed_buffer, 2) == 3)) && (_halide_buffer_get_stride_uint8_t(_processed_buffer, 2) == 4915200);
 context (\forall* int _0, int _1, int _2; (((((0 <= _0) && (_0 < 2560)) && (0 <= _1)) && (_1 < 1920)) && (0 <= _2)) && (_2 < 3); Perm(&_processed_buffer->host[(_2*4915200) + ((_1*2560) + _0)], 1\1));
@*/
int camera_pipe_mem(struct halide_buffer_uint16_t *_input_buffer, struct halide_buffer_float *_matrix_3200_buffer, struct halide_buffer_float *_matrix_7000_buffer, struct halide_buffer_uint8_t *_processed_buffer) {
 uint16_t* _input = _halide_buffer_get_host_uint16_t(_input_buffer);
//  int32_t _input_min_0 = _halide_buffer_get_min_uint16_t(_input_buffer, 0);
//  int32_t _input_extent_0 = _halide_buffer_get_extent_uint16_t(_input_buffer, 0);
//  int32_t _input_stride_0 = _halide_buffer_get_stride_uint16_t(_input_buffer, 0);
//  int32_t _input_min_1 = _halide_buffer_get_min_uint16_t(_input_buffer, 1);
//  int32_t _input_extent_1 = _halide_buffer_get_extent_uint16_t(_input_buffer, 1);
//  int32_t _input_stride_1 = _halide_buffer_get_stride_uint16_t(_input_buffer, 1);
 float* _matrix_3200 = _halide_buffer_get_host_float(_matrix_3200_buffer);
//  int32_t _matrix_3200_min_0 = _halide_buffer_get_min_float(_matrix_3200_buffer, 0);
//  int32_t _matrix_3200_extent_0 = _halide_buffer_get_extent_float(_matrix_3200_buffer, 0);
//  int32_t _matrix_3200_stride_0 = _halide_buffer_get_stride_float(_matrix_3200_buffer, 0);
//  int32_t _matrix_3200_min_1 = _halide_buffer_get_min_float(_matrix_3200_buffer, 1);
//  int32_t _matrix_3200_extent_1 = _halide_buffer_get_extent_float(_matrix_3200_buffer, 1);
//  int32_t _matrix_3200_stride_1 = _halide_buffer_get_stride_float(_matrix_3200_buffer, 1);
 float* _matrix_7000 = _halide_buffer_get_host_float(_matrix_7000_buffer);
//  int32_t _matrix_7000_min_0 = _halide_buffer_get_min_float(_matrix_7000_buffer, 0);
//  int32_t _matrix_7000_extent_0 = _halide_buffer_get_extent_float(_matrix_7000_buffer, 0);
//  int32_t _matrix_7000_stride_0 = _halide_buffer_get_stride_float(_matrix_7000_buffer, 0);
//  int32_t _matrix_7000_min_1 = _halide_buffer_get_min_float(_matrix_7000_buffer, 1);
//  int32_t _matrix_7000_extent_1 = _halide_buffer_get_extent_float(_matrix_7000_buffer, 1);
//  int32_t _matrix_7000_stride_1 = _halide_buffer_get_stride_float(_matrix_7000_buffer, 1);
 uint8_t* _processed = _halide_buffer_get_host_uint8_t(_processed_buffer);
//  int32_t _processed_min_0 = _halide_buffer_get_min_uint8_t(_processed_buffer, 0);
//  int32_t _processed_extent_0 = _halide_buffer_get_extent_uint8_t(_processed_buffer, 0);
//  int32_t _processed_stride_0 = _halide_buffer_get_stride_uint8_t(_processed_buffer, 0);
//  int32_t _processed_min_1 = _halide_buffer_get_min_uint8_t(_processed_buffer, 1);
//  int32_t _processed_extent_1 = _halide_buffer_get_extent_uint8_t(_processed_buffer, 1);
//  int32_t _processed_stride_1 = _halide_buffer_get_stride_uint8_t(_processed_buffer, 1);
//  int32_t _processed_min_2 = _halide_buffer_get_min_uint8_t(_processed_buffer, 2);
//  int32_t _processed_extent_2 = _halide_buffer_get_extent_uint8_t(_processed_buffer, 2);
//  int32_t _processed_stride_2 = _halide_buffer_get_stride_uint8_t(_processed_buffer, 2);
//  halide_unused((_input_stride_0 == 1));
//  halide_unused((_input_min_0 == 0));
//  halide_unused((_input_extent_0 == 2592));
//  halide_unused((_input_stride_1 == 2592));
//  halide_unused((_input_min_1 == 0));
//  halide_unused((_input_extent_1 == 1968));
//  halide_unused((_matrix_3200_stride_0 == 1));
//  halide_unused((_matrix_3200_min_0 == 0));
//  halide_unused((_matrix_3200_extent_0 == 4));
//  halide_unused((_matrix_3200_stride_1 == 4));
//  halide_unused((_matrix_3200_min_1 == 0));
//  halide_unused((_matrix_3200_extent_1 == 3));
//  halide_unused((_matrix_7000_stride_0 == 1));
//  halide_unused((_matrix_7000_min_0 == 0));
//  halide_unused((_matrix_7000_extent_0 == 4));
//  halide_unused((_matrix_7000_stride_1 == 4));
//  halide_unused((_matrix_7000_min_1 == 0));
//  halide_unused((_matrix_7000_extent_1 == 3));
//  halide_unused((_processed_stride_0 == 1));
//  halide_unused((_processed_min_0 == 0));
//  halide_unused((_processed_extent_0 == 2560));
//  halide_unused((_processed_stride_1 == 2560));
//  halide_unused((_processed_min_1 == 0));
//  halide_unused((_processed_extent_1 == 1920));
//  halide_unused((_processed_stride_2 == 4915200));
//  halide_unused((_processed_min_2 == 0));
//  halide_unused((_processed_extent_2 == 3));
 {
  uint8_t _curve[1024];
  // produce curve
  /*@
   loop_invariant 0 <= _curve_s0_v0 && _curve_s0_v0 <= 0 + 1024;
   loop_invariant (\forall* int _curve_s0_v0_forall; (0 <= _curve_s0_v0_forall) && (_curve_s0_v0_forall < 1024); Perm(&_curve[_curve_s0_v0_forall], 1\1));
  @*/
  for (int _curve_s0_v0 = 0; _curve_s0_v0 < 0 + 1024; _curve_s0_v0++)
  {
   float _4 = (float)((_curve_s0_v0 + -25));
   float _5 = (_4 * 0.001002)<1.000000 ? (_4 * 0.001002) : 1.000000;
   float _6 = _5>0.000000 ? _5 : 0.000000;
   float _t1568 = pow_f32(_6, 0.500000);
   float _7 = (((0.500000 < _t1568) ? (0.414214 - (((1.000000 - _t1568) * ((_t1568 * -0.828427) + 0.828427)) + (_t1568 * -0.585786))) : (((_t1568 * _t1568) * 0.828427) + (_t1568 * 0.585786))) * 255.000000)<254.500000 ? (((0.500000 < _t1568) ? (0.414214 - (((1.000000 - _t1568) * ((_t1568 * -0.828427) + 0.828427)) + (_t1568 * -0.585786))) : (((_t1568 * _t1568) * 0.828427) + (_t1568 * 0.585786))) * 255.000000) : 254.500000;
   float _8 = _7>-0.500000 ? _7 : -0.500000;
   uint8_t _9 = (uint8_t)((_8 + 0.500000));
   _curve[_curve_s0_v0] = ((25 < _curve_s0_v0) ? _9 : 0);
  } // for _curve_s0_v0
  {
   int16_t _f26[12];
   // produce f26
   /*@
    loop_invariant 0 <= _f26_s0_v1 && _f26_s0_v1 <= 0 + 3;
    loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 4)) && ((0 <= _1) && (_1 < 3)); Perm(&_matrix_3200[(_1*4) + _0], 1\2));
    //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); _matrix_3200[(_1*4) + _0] == pure_matrix_3200((_1*4) + _0));
    loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 4)) && ((0 <= _1) && (_1 < 3)); Perm(&_matrix_7000[(_1*4) + _0], 1\2));
    //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); _matrix_7000[(_1*4) + _0] == pure_matrix_7000((_1*4) + _0));
    loop_invariant (\forall* int _f26_s0_v0_forall, int _f26_s0_v1_forall; (((0 <= _f26_s0_v1_forall) && (_f26_s0_v1_forall < 3)) && (0 <= _f26_s0_v0_forall)) && (_f26_s0_v0_forall < 4); Perm(&_f26[(_f26_s0_v1_forall*4) + _f26_s0_v0_forall], 1\1));
   @*/
   for (int _f26_s0_v1 = 0; _f26_s0_v1 < 0 + 3; _f26_s0_v1++)
   {
    int32_t _t1633 = (_f26_s0_v1 * 4);
    /*@
     loop_invariant 0 <= _f26_s0_v0 && _f26_s0_v0 <= 0 + 4;
     loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 4)) && ((0 <= _1) && (_1 < 3)); Perm(&_matrix_3200[(_1*4) + _0], 1\2));
     //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); _matrix_3200[(_1*4) + _0] == pure_matrix_3200((_1*4) + _0));
     loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 4)) && ((0 <= _1) && (_1 < 3)); Perm(&_matrix_7000[(_1*4) + _0], 1\2));
     //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 4)) && (0 <= _1)) && (_1 < 3); _matrix_7000[(_1*4) + _0] == pure_matrix_7000((_1*4) + _0));
     loop_invariant (\forall* int _f26_s0_v0_forall; (0 <= _f26_s0_v0_forall) && (_f26_s0_v0_forall < 4); Perm(&_f26[(_f26_s0_v1*4) + _f26_s0_v0_forall], 1\1));
    @*/
    for (int _f26_s0_v0 = 0; _f26_s0_v0 < 0 + 4; _f26_s0_v0++)
    {
     int32_t _t1630 = (_f26_s0_v0 + _t1633);
     int16_t _10 = (int16_t)((((_matrix_3200[_t1630] * 0.248933) + (_matrix_7000[_t1630] * 0.751067)) * 256.000000));
     _f26[_t1630] = _10;
    } // for _f26_s0_v0
   } // for _f26_s0_v1
   {
    uint8_t _sharpen_strength_x32[1];
    // produce sharpen_strength_x32
    _sharpen_strength_x32[0] = 32;
    // produce processed
    // consume sharpen_strength_x32
    // consume f26
    // consume curve
    #pragma omp parallel for
    for (int _processed_s0_v1_v3_v4 = 0; _processed_s0_v1_v3_v4 < 0 + 60; _processed_s0_v1_v3_v4++)
    /*@
     context 0 <= _processed_s0_v1_v3_v4 && _processed_s0_v1_v3_v4 < 0 + 60;
     context (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
     //context (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
     context (\forall* int _v0; (0 <= _v0) && (_v0 < 1024); Perm(&_curve[_v0], 1\(2*60)));
     context (\forall* int _v0, int _v1; (((0 <= _v0) && (_v0 < 4)) && (0 <= _v1)) && (_v1 < 3); Perm(&_f26[(_v1*4) + _v0], 1\(2*60)));
     context Perm(&_sharpen_strength_x32[0], 1\(2*60));
     context (\forall* int _processed_s0_v2_forall, int _processed_s0_v0_forall, int _processed_s0_v1_v5_forall, int _processed_s0_v1_v3_v3_forall; (((((((0 <= _processed_s0_v1_v3_v3_forall) && (_processed_s0_v1_v3_v3_forall < 16)) && (0 <= _processed_s0_v1_v5_forall)) && (_processed_s0_v1_v5_forall < 2)) && (0 <= _processed_s0_v0_forall)) && (_processed_s0_v0_forall < 2560)) && (0 <= _processed_s0_v2_forall)) && (_processed_s0_v2_forall < 3); Perm(&_processed[(((((_processed_s0_v1_v3_v4*16) + _processed_s0_v1_v3_v3_forall)*2) + _processed_s0_v1_v5_forall)*2560) + ((_processed_s0_v2_forall*4915200) + _processed_s0_v0_forall)], 1\1));
    @*/
    {
     {
      int64_t _11 = 102720;
      int16_t *_f3 = (int16_t  *)malloc(sizeof(int16_t )*_11);
      {
       int64_t _12 = 103280;
       int16_t *_deinterleaved = (int16_t  *)malloc(sizeof(int16_t )*_12);
       {
        int64_t _13 = 262752;
        uint8_t *_curved = (uint8_t  *)malloc(sizeof(uint8_t )*_13);
        int32_t _t1634 = (_processed_s0_v1_v3_v4 * 16);
        /*@
         loop_invariant 0 <= _processed_s0_v1_v3_v3 && _processed_s0_v1_v3_v3 <= 0 + 16;
         //loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
        //  loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
         //loop_invariant (\forall* int _v0; (0 <= _v0) && (_v0 < 1024); Perm(&_curve[_v0], 1\(2*60)));
         //loop_invariant (\forall* int _v0, int _v1; (((0 <= _v0) && (_v0 < 4)) && (0 <= _v1)) && (_v1 < 3); Perm(&_f26[(_v1*4) + _v0], 1\(2*60)));
         loop_invariant (\forall* int _v0, int _v1; (((-4 <= _v0) && (_v0 < 2564)) && (((_processed_s0_v1_v3_v4*32) + -4) <= _v1)) && (_v1 < ((_processed_s0_v1_v3_v4*32) + 36)); Perm(&_f3[(((_v1 - (_processed_s0_v1_v3_v4*32))*2568) + _v0) + 10276], 1\1));
         //loop_invariant (\forall* int _v0, int _v1, int _v2; (((((-2 <= _v0) && (_v0 < 1289)) && (((_processed_s0_v1_v3_v4*16) + -2) <= _v1)) && (_v1 < ((_processed_s0_v1_v3_v4*16) + 18))) && (0 <= _v2)) && (_v2 < 4); Perm(&_deinterleaved[(((_v1 - (_processed_s0_v1_v3_v4*16))*1291) + ((_v2*25820) + _v0)) + 2584], 1\1));
         //loop_invariant (\forall* int _v0, int _v1, int _v2; (((((-1 <= _v0) && (_v0 < 2575)) && (((_processed_s0_v1_v3_v4*32) + -1) <= _v1)) && (_v1 < ((_processed_s0_v1_v3_v4*32) + 33))) && (0 <= _v2)) && (_v2 < 3); Perm(&_curved[(((_v1 - (_processed_s0_v1_v3_v4*32))*2576) + ((_v2*87584) + _v0)) + 2577], 1\1));
         //loop_invariant Perm(&_sharpen_strength_x32[0], 1\(2*60));
         //loop_invariant (\forall* int _processed_s0_v2_forall, int _processed_s0_v0_forall, int _processed_s0_v1_v5_forall, int _processed_s0_v1_v3_v3_forall; (((((((0 <= _processed_s0_v1_v3_v3_forall) && (_processed_s0_v1_v3_v3_forall < 16)) && (0 <= _processed_s0_v1_v5_forall)) && (_processed_s0_v1_v5_forall < 2)) && (0 <= _processed_s0_v0_forall)) && (_processed_s0_v0_forall < 2560)) && (0 <= _processed_s0_v2_forall)) && (_processed_s0_v2_forall < 3); Perm(&_processed[(((((_processed_s0_v1_v3_v4*16) + _processed_s0_v1_v3_v3_forall)*2) + _processed_s0_v1_v5_forall)*2560) + ((_processed_s0_v2_forall*4915200) + _processed_s0_v0_forall)], 1\1));
        @*/
        for (int _processed_s0_v1_v3_v3 = 0; _processed_s0_v1_v3_v3 < 0 + 16; _processed_s0_v1_v3_v3++)
        {
         // produce f3
         int32_t _t1635 = (_processed_s0_v1_v3_v3 + _t1634);
         /*@
          loop_invariant 0 <= _f3_s0_v1_v1 && _f3_s0_v1_v1 <= 0 + 5;
          //loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
          //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
          loop_invariant (\forall* int _f3_s0_v0_v6_forall, int _f3_s0_v1_v3_forall, int _f3_s0_v0_v0_forall, int _f3_s0_v1_v1_forall; ((((((((0 <= _f3_s0_v1_v1_forall) && (_f3_s0_v1_v1_forall < 5)) && (0 <= _f3_s0_v0_v0_forall)) && (_f3_s0_v0_v0_forall < 161)) && (0 <= _f3_s0_v1_v3_forall)) && (_f3_s0_v1_v3_forall < 2)) && (0 <= _f3_s0_v0_v6_forall)) && (_f3_s0_v0_v6_forall < 16)) && (((_f3_s0_v0_v0_forall*16) + _f3_s0_v0_v6_forall) <= 2567); Perm(&_f3[((((_f3_s0_v1_v1_forall + _processed_s0_v1_v3_v3)*2) + _f3_s0_v1_v3_forall)*2568) + ((_f3_s0_v0_v0_forall*16) + _f3_s0_v0_v6_forall)], 1\1));
         @*/
         for (int _f3_s0_v1_v1 = 0; _f3_s0_v1_v1 < 0 + 5; _f3_s0_v1_v1++)
         {
          int32_t _t1636 = ((_f3_s0_v1_v1 + _t1635) * 2);
          int32_t _t1637 = ((_f3_s0_v1_v1 + _processed_s0_v1_v3_v3) * 2);
          /*@
           loop_invariant 0 <= _f3_s0_v0_v0 && _f3_s0_v0_v0 <= 0 + 160;
           //loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
           //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
           loop_invariant (\forall* int _f3_s0_v0_v6_forall, int _f3_s0_v1_v3_forall, int _f3_s0_v0_v0_forall; ((((((0 <= _f3_s0_v0_v0_forall) && (_f3_s0_v0_v0_forall < 161)) && (0 <= _f3_s0_v1_v3_forall)) && (_f3_s0_v1_v3_forall < 2)) && (0 <= _f3_s0_v0_v6_forall)) && (_f3_s0_v0_v6_forall < 16)) && (((_f3_s0_v0_v0_forall*16) + _f3_s0_v0_v6_forall) <= 2567); Perm(&_f3[((((_f3_s0_v1_v1 + _processed_s0_v1_v3_v3)*2) + _f3_s0_v1_v3_forall)*2568) + ((_f3_s0_v0_v0_forall*16) + _f3_s0_v0_v6_forall)], 1\1));
          @*/
          for (int _f3_s0_v0_v0 = 0; _f3_s0_v0_v0 < 0 + 160; _f3_s0_v0_v0++)
          {
           int32_t _t1638 = (_f3_s0_v0_v0 * 16);
           /*@
            loop_invariant 0 <= _f3_s0_v1_v3 && _f3_s0_v1_v3 <= 0 + 2;
            //loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
            //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
            loop_invariant (\forall* int _f3_s0_v0_v6_forall, int _f3_s0_v1_v3_forall; (((0 <= _f3_s0_v1_v3_forall) && (_f3_s0_v1_v3_forall < 2)) && (0 <= _f3_s0_v0_v6_forall)) && (_f3_s0_v0_v6_forall < 16); Perm(&_f3[(_f3_s0_v0_v0*16) + (((((_f3_s0_v1_v1 + _processed_s0_v1_v3_v3)*2) + _f3_s0_v1_v3_forall)*2568) + _f3_s0_v0_v6_forall)], 1\1));
           @*/
           for (int _f3_s0_v1_v3 = 0; _f3_s0_v1_v3 < 0 + 2; _f3_s0_v1_v3++)
           {
            int32_t _t1640 = (((_f3_s0_v1_v3 + _t1637) * 2568) + _t1638);
            int32_t _t1639 = (((_f3_s0_v1_v3 + _t1636) * 2592) + _t1638);
            /*@
             loop_invariant 0 <= _f3_s0_v0_v6 && _f3_s0_v0_v6 <= 0 + 16;
             //loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
             //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
             loop_invariant (\forall* int _f3_s0_v0_v6_forall; (0 <= _f3_s0_v0_v6_forall) && (_f3_s0_v0_v6_forall < 16); Perm(&_f3[((((_f3_s0_v1_v1 + _processed_s0_v1_v3_v3)*2) + _f3_s0_v1_v3)*2568) + ((_f3_s0_v0_v0*16) + _f3_s0_v0_v6_forall)], 1\1));
            @*/
            for (int _f3_s0_v0_v6 = 0; _f3_s0_v0_v6 < 0 + 16; _f3_s0_v0_v6++)
            {
            //  int32_t _t1571 = (_f3_s0_v0_v6 + _t1639);
            //  int16_t _14 = (int16_t)(_input[(_t1571 + 15564)]);
            //  int16_t _15 = (int16_t)(_input[(_t1571 + 25932)]);
            //  int16_t _16 = _14>_15 ? _14 : _15;
            //  int16_t _17 = (int16_t)(_input[(_t1571 + 20750)]);
            //  int16_t _18 = _16>_17 ? _16 : _17;
            //  int16_t _19 = (int16_t)(_input[(_t1571 + 20746)]);
            //  int16_t _20 = _18>_19 ? _18 : _19;
            //  int16_t _21 = (int16_t)(_input[(_t1571 + 20748)]);
            //  int16_t _22 = _20<_21 ? _20 : _21;
            //  int16_t _23 = _22>0 ? _22 : 0;
             _f3[(_f3_s0_v0_v6 + _t1640)] = 0;//_23;
            } // for _f3_s0_v0_v6
           } // for _f3_s0_v1_v3
          } // for _f3_s0_v0_v0
          int32_t _t1641 = ((_f3_s0_v1_v1 + _t1635) * 2);
          int32_t _t1642 = ((_f3_s0_v1_v1 + _processed_s0_v1_v3_v3) * 2);
          /*@
           loop_invariant 0 <= _f3_s0_v1_v3 && _f3_s0_v1_v3 <= 0 + 2;
           //loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
           //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
           loop_invariant (\forall* int _f3_s0_v0_v6_forall, int _f3_s0_v1_v3_forall; ((((0 <= _f3_s0_v1_v3_forall) && (_f3_s0_v1_v3_forall < 2)) && (0 <= _f3_s0_v0_v6_forall)) && (_f3_s0_v0_v6_forall < 16)) && (_f3_s0_v0_v6_forall <= 7); Perm(&_f3[(((((_f3_s0_v1_v1 + _processed_s0_v1_v3_v3)*2) + _f3_s0_v1_v3_forall)*2568) + _f3_s0_v0_v6_forall) + 2560], 1\1));
          @*/
          for (int _f3_s0_v1_v3 = 0; _f3_s0_v1_v3 < 0 + 2; _f3_s0_v1_v3++)
          {
           int32_t _t1644 = ((_f3_s0_v1_v3 + _t1642) * 2568);
           int32_t _t1643 = ((_f3_s0_v1_v3 + _t1641) * 2592);
           /*@
            loop_invariant 0 <= _f3_s0_v0_v6 && _f3_s0_v0_v6 <= 0 + 8;
            //loop_invariant (\forall* int _0, int _1; ((0 <= _0) && (_0 < 2592)) && ((0 <= _1) && (_1 < 1968)); Perm(&_input[(_1*2592) + _0], 1\(2*60)));
            //loop_invariant (\forall int _0, int _1; (((0 <= _0) && (_0 < 2592)) && (0 <= _1)) && (_1 < 1968); _input[(_1*2592) + _0] == pure_input((_1*2592) + _0));
            loop_invariant (\forall* int _f3_s0_v0_v6_forall; ((0 <= _f3_s0_v0_v6_forall) && (_f3_s0_v0_v6_forall < 16)) && (_f3_s0_v0_v6_forall <= 7); Perm(&_f3[(((((_f3_s0_v1_v1 + _processed_s0_v1_v3_v3)*2) + _f3_s0_v1_v3)*2568) + _f3_s0_v0_v6_forall) + 2560], 1\1));
           @*/
           for (int _f3_s0_v0_v6 = 0; _f3_s0_v0_v6 < 0 + 8; _f3_s0_v0_v6++)
           {
            // int32_t _t1631 = (_f3_s0_v0_v6 + _t1643);
            // int16_t _24 = (int16_t)(_input[(_t1631 + 18124)]);
            // int16_t _25 = (int16_t)(_input[(_t1631 + 28492)]);
            // int16_t _26 = _24>_25 ? _24 : _25;
            // int16_t _27 = (int16_t)(_input[(_t1631 + 23310)]);
            // int16_t _28 = _26>_27 ? _26 : _27;
            // int16_t _29 = (int16_t)(_input[(_t1631 + 23306)]);
            // int16_t _30 = _28>_29 ? _28 : _29;
            // int16_t _31 = (int16_t)(_input[(_t1631 + 23308)]);
            // int16_t _32 = _30<_31 ? _30 : _31;
            // int16_t _33 = _32>0 ? _32 : 0;
            _f3[((_f3_s0_v0_v6 + _t1644) + 2560)] = 0;//_33;
           } // for _f3_s0_v0_v6
          } // for _f3_s0_v1_v3
         } // for _f3_s0_v1_v1
        } // for _processed_s0_v1_v3_v3
        free(_f3);
        free(_deinterleaved);
        free(_curved);
       } // alloc _curved
      } // alloc _deinterleaved
     } // alloc _f3
    } // for _processed_s0_v1_v3_v4
   } // alloc _sharpen_strength_x32
  } // alloc _f26
 } // alloc _curve
 return 0;
}

#ifdef __cplusplus
}  // extern "C"
#endif

